substitutions:
  name: esp32-screen
  friendly_name: ESP32-Screen
esphome:
  name: ${name}
  friendly_name: ${friendly_name}

esp32:
  board: esp32-s3-devkitc-1
  variant: esp32s3
  flash_size: 16MB
  framework:
    type: esp-idf
    sdkconfig_options:
      COMPILER_OPTIMIZATION_SIZE: y
      CONFIG_ESP32S3_DEFAULT_CPU_FREQ_240: y
      CONFIG_ESP32S3_DATA_CACHE_64KB: y
      CONFIG_ESP32S3_DATA_CACHE_LINE_64B: y
      CONFIG_SPIRAM_FETCH_INSTRUCTIONS: y
      CONFIG_SPIRAM_RODATA: y  

# Enable logging
logger:

wifi:
  ssid: !secret wifi_ssid
  password: !secret wifi_password

  # Enable fallback hotspot (captive portal) in case wifi connection fails
  ap:
    ssid: ${friendly_name}
    password: !secret wifi_password

# Enable Home Assistant API
api:
  password: !secret ha_api_password
  encryption: 
    key: !secret encryption_key

ota:
  platform: esphome
  password: !secret ota_password

captive_portal:
  
psram:
  mode: octal
  speed: 80MHz

spi:
  clk_pin: 48
  mosi_pin: 47
#  miso_pin: 41

i2c:
  - id: bus_a
    sda: 19
    scl: 45
    scan: false
    #frequency: 100kHz

switch:
  - platform: gpio
    pin: 40
    id: relay1
    name: Relay 1

  - platform: gpio
    pin: 2
    id: relay2
    name: Relay 2

  - platform: gpio
    pin: 1
    id: relay3
    name: Relay 3

output:
  - platform: ledc
    pin: GPIO38
    id: bl_led_pin
    inverted: False

light:
  - platform: monochromatic
    output: bl_led_pin
    name: "Display Backlight"
    id: back_light
    restore_mode: ALWAYS_ON


font:
  - file: 'fonts/arial.ttf'
    id: arial
    size: 18

  - file: 'fonts/arial.ttf'
    id: arial_big
    size: 96


# Global Variables to Store Entity States
globals:

# Update entity states from Home Assistant

sensor:

binary_sensor:
  - platform: status
    id: status_sensor
    internal: True
    on_press: 
      then:
        - component.update: display4inch
  
display:
  - platform: st7701s
    id: display4inch
    update_interval: 5s
    auto_clear_enabled: False
    spi_mode: MODE3
    data_rate: 2MHz
    color_order: RGB
    invert_colors: False
    dimensions:
      width: 480
      height: 480
    cs_pin: 39
    de_pin: 18
    hsync_pin: 16
    vsync_pin: 17
    pclk_pin: 21
    pclk_frequency: 12MHz
    pclk_inverted: False
    hsync_pulse_width: 8
    hsync_front_porch: 10
    hsync_back_porch: 20
    vsync_pulse_width: 8
    vsync_front_porch: 10
    vsync_back_porch: 10
    init_sequence:
      - 1
      # Custom sequences are an array, first byte is command, the rest are data.
      - [ 0xFF, 0x77, 0x01, 0x00, 0x00, 0x10 ] # CMD2_BKSEL_BK0
      - [0xCD, 0x00] # disable MDT flag
    data_pins:
      red:
        - 11        #r1
        - 12        #r2
        - 13        #r3
        - 14        #r4
        - 0         #r5
      green:
        - 8         #g0
        - 20        #g1
        - 3         #g2
        - 46        #g3
        - 9         #g4
        - 10        #g5
      blue:
        - 4         #b1
        - 5         #b2
        - 6         #b3
        - 7         #b4
        - 15        #b5
    pages:
      - id: deff
        lambda: |-
          // it.fill(COLOR_BLACK);
          it.filled_rectangle(0, 0, 200, 200, id(my_black));
          it.print(50, 50, id(arial), id(my_red), TextAlign::TOP_LEFT, "Hello Dale!");

          // Display Relay 1
          it.printf(50, 150, id(arial), Color::WHITE, "Relay 1: %s", id(relay1).state ? "ON" : "OFF");

          // Display Relay 2
          it.printf(50, 200, id(arial), Color::WHITE, "Relay 2: %s", id(relay2).state ? "ON" : "OFF");

          // Display Relay 3
          it.printf(50, 250, id(arial), Color::WHITE, "Relay 3: %s", id(relay3).state ? "ON" : "OFF");


touchscreen:
  platform: gt911
  id: touchscreen_4_inches
  i2c_id: bus_a
  on_touch:
    then:
      - if:
          condition:
            lambda: 'return touch.x > 50 && touch.x < 80 && touch.y > 150 && touch.y < 190;'
          then:
            - switch.toggle:
                id: relay1
      - if:
          condition:
            lambda: 'return touch.x > 50 && touch.x < 80 && touch.y > 200 && touch.y < 240;'
          then:
            - switch.toggle:
                id: relay2
      - if:
          condition:
            lambda: 'return touch.x > 50 && touch.x < 80 && touch.y > 250 && touch.y < 290;'
          then:
            - switch.toggle:
                id: relay3

      - component.update: display4inch # Update the display after toggling
      
      - logger.log: 
          format: Touch at (%d, %d)
          args: [touch.x, touch.y]

      - lambda: |-
            ESP_LOGI("cal", "x=%d, y=%d, x_raw=%d, y_raw=%0d",
                touch.x,
                touch.y,
                touch.x_raw,
                touch.y_raw
                );


color:
  - id: my_white
    red: 100%
    green: 100%
    blue: 100%
  - id: my_red
    red: 100%
    green: 0%
    blue: 0%
  - id: my_black
    red: 2%
    green: 2%
    blue: 0%
